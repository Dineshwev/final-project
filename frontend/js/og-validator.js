/**
 * Open Graph Validator - Client-side functionality
 * Handles validation requests and UI updates
 */

// API Configuration
const OG_VALIDATOR_API = `${
  window.API_BASE_URL || "https://bc-worker-env.eba-k8rrjwx.ap-southeast-2.elasticbeanstalk.com/api"
}/og-validator`;

/**
 * Validate Open Graph tags for a given URL
 * @param {string} url - URL to validate
 * @returns {Promise<Object>} Validation results
 */
async function validateOpenGraph(url) {
  if (!url) {
    throw new Error("URL is required");
  }

  // Validate URL format
  try {
    new URL(url);
  } catch (e) {
    throw new Error(
      "Invalid URL format. Please enter a valid URL (e.g., https://example.com)"
    );
  }

  const response = await fetch(`${OG_VALIDATOR_API}/validate`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
    },
    body: JSON.stringify({ url }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(
      errorData.error || `HTTP error! status: ${response.status}`
    );
  }

  const result = await response.json();

  if (!result.success) {
    throw new Error(result.error || "Validation failed");
  }

  return result.data;
}

/**
 * Check OG Validator API health
 * @returns {Promise<boolean>} Health status
 */
async function checkOGValidatorHealth() {
  try {
    const response = await fetch(`${OG_VALIDATOR_API}/health`, {
      method: "GET",
      headers: {
        Accept: "application/json",
      },
    });

    if (response.ok) {
      const data = await response.json();
      return data.success && data.status === "operational";
    }
    return false;
  } catch (error) {
    console.error("OG Validator health check failed:", error);
    return false;
  }
}

/**
 * Format validation data for display
 * @param {Object} data - Validation data
 * @returns {Object} Formatted data
 */
function formatValidationData(data) {
  return {
    ...data,
    formattedTimestamp: new Date(data.timestamp).toLocaleString(),
    scorePercentage: Math.round(
      (data.summary.requiredTagsPresent / data.summary.requiredTagsTotal) * 100
    ),
    hasErrors: data.errors.length > 0,
    hasWarnings: data.warnings.length > 0,
    hasRecommendations: data.recommendations.length > 0,
  };
}

/**
 * Generate a shareable report
 * @param {Object} data - Validation data
 * @returns {string} Report text
 */
function generateShareableReport(data) {
  let report = `Open Graph Validation Report\n`;
  report += `URL: ${data.url}\n`;
  report += `Date: ${new Date(data.timestamp).toLocaleString()}\n`;
  report += `Status: ${data.isValid ? "VALID ✅" : "INVALID ❌"}\n\n`;

  report += `Summary:\n`;
  report += `- Total Tags: ${data.summary.totalTags}\n`;
  report += `- Required Tags: ${data.summary.requiredTagsPresent}/${data.summary.requiredTagsTotal}\n`;
  report += `- Errors: ${data.summary.errorsCount}\n`;
  report += `- Warnings: ${data.summary.warningsCount}\n\n`;

  if (Object.keys(data.tags).length > 0) {
    report += `Open Graph Tags:\n`;
    for (const [key, value] of Object.entries(data.tags)) {
      report += `- og:${key}: ${value.substring(0, 100)}${
        value.length > 100 ? "..." : ""
      }\n`;
    }
    report += `\n`;
  }

  if (data.errors.length > 0) {
    report += `Errors:\n`;
    data.errors.forEach((error, i) => {
      report += `${i + 1}. ${error}\n`;
    });
    report += `\n`;
  }

  if (data.warnings.length > 0) {
    report += `Warnings:\n`;
    data.warnings.forEach((warning, i) => {
      report += `${i + 1}. ${warning}\n`;
    });
    report += `\n`;
  }

  report += `Generated by Healthy SEO - Open Graph Validator\n`;

  return report;
}

/**
 * Export validation report as JSON
 * @param {Object} data - Validation data
 * @param {string} filename - Optional filename
 */
function exportAsJSON(data, filename) {
  const name =
    filename || `og-validation-${new Date().toISOString().split("T")[0]}.json`;
  const blob = new Blob([JSON.stringify(data, null, 2)], {
    type: "application/json",
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Export validation report as text
 * @param {Object} data - Validation data
 * @param {string} filename - Optional filename
 */
function exportAsText(data, filename) {
  const name =
    filename || `og-validation-${new Date().toISOString().split("T")[0]}.txt`;
  const report = generateShareableReport(data);
  const blob = new Blob([report], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Copy validation report to clipboard
 * @param {Object} data - Validation data
 * @returns {Promise<void>}
 */
async function copyReportToClipboard(data) {
  const report = generateShareableReport(data);
  await navigator.clipboard.writeText(report);
}

/**
 * Save validation to history (localStorage)
 * @param {Object} data - Validation data
 */
function saveToHistory(data) {
  try {
    const history = JSON.parse(
      localStorage.getItem("og_validation_history") || "[]"
    );

    // Add new validation
    history.unshift({
      url: data.url,
      isValid: data.isValid,
      timestamp: data.timestamp,
      summary: data.summary,
    });

    // Keep only last 50 validations
    if (history.length > 50) {
      history.splice(50);
    }

    localStorage.setItem("og_validation_history", JSON.stringify(history));
  } catch (error) {
    console.error("Failed to save to history:", error);
  }
}

/**
 * Get validation history from localStorage
 * @returns {Array} History items
 */
function getValidationHistory() {
  try {
    return JSON.parse(localStorage.getItem("og_validation_history") || "[]");
  } catch (error) {
    console.error("Failed to load history:", error);
    return [];
  }
}

/**
 * Clear validation history
 */
function clearValidationHistory() {
  localStorage.removeItem("og_validation_history");
}

/**
 * Get OG tag recommendations
 * @param {string} tagName - Tag name (without og: prefix)
 * @returns {Object} Recommendation details
 */
function getTagRecommendation(tagName) {
  const recommendations = {
    title: {
      description:
        "The title of your content as it should appear in social media shares",
      optimal: "60-90 characters",
      example: "Best SEO Tools for 2025 | Complete Guide",
      required: true,
    },
    description: {
      description: "A brief description of your content",
      optimal: "150-300 characters",
      example:
        "Discover the top SEO tools that will help you rank higher in 2025. Complete guide with pros, cons, and pricing.",
      required: true,
    },
    image: {
      description: "An image URL that represents your content",
      optimal: "1200x630px, aspect ratio 1.91:1",
      example: "https://example.com/images/og-image.jpg",
      required: true,
    },
    url: {
      description: "The canonical URL of your page",
      optimal: "Should match the actual page URL",
      example: "https://example.com/article",
      required: true,
    },
    type: {
      description: "The type of content",
      optimal: "website, article, video.movie, etc.",
      example: "article",
      required: false,
    },
    site_name: {
      description: "The name of your website",
      optimal: "Your brand/site name",
      example: "Healthy SEO",
      required: false,
    },
  };

  return recommendations[tagName] || null;
}

/**
 * Validate individual OG tag
 * @param {string} tagName - Tag name
 * @param {string} value - Tag value
 * @returns {Object} Validation result
 */
function validateIndividualTag(tagName, value) {
  const result = {
    valid: true,
    warnings: [],
    recommendations: [],
  };

  if (!value || value.trim() === "") {
    result.valid = false;
    result.warnings.push("Tag value is empty");
    return result;
  }

  switch (tagName) {
    case "title":
      if (value.length < 60) {
        result.warnings.push(
          `Title is short (${value.length} chars). Optimal: 60-90 characters`
        );
      } else if (value.length > 90) {
        result.warnings.push(
          `Title is long (${value.length} chars). May be truncated in shares`
        );
      } else {
        result.recommendations.push("Title length is optimal");
      }
      break;

    case "description":
      if (value.length < 150) {
        result.warnings.push(
          `Description is short (${value.length} chars). Optimal: 150-300 characters`
        );
      } else if (value.length > 300) {
        result.warnings.push(
          `Description is long (${value.length} chars). May be truncated in shares`
        );
      } else {
        result.recommendations.push("Description length is optimal");
      }
      break;

    case "url":
      try {
        new URL(value);
        result.recommendations.push("URL is valid");
      } catch (e) {
        result.valid = false;
        result.warnings.push("URL format is invalid");
      }
      break;

    case "image":
      try {
        const url = new URL(value);
        if (!url.protocol.startsWith("http")) {
          result.warnings.push("Image URL should use HTTP or HTTPS protocol");
        }
        result.recommendations.push("Image URL is valid");
      } catch (e) {
        result.valid = false;
        result.warnings.push("Image URL format is invalid");
      }
      break;
  }

  return result;
}

// Export functions for global use
if (typeof window !== "undefined") {
  window.OGValidator = {
    validate: validateOpenGraph,
    checkHealth: checkOGValidatorHealth,
    format: formatValidationData,
    export: {
      json: exportAsJSON,
      text: exportAsText,
      copy: copyReportToClipboard,
    },
    history: {
      save: saveToHistory,
      get: getValidationHistory,
      clear: clearValidationHistory,
    },
    utils: {
      getRecommendation: getTagRecommendation,
      validateTag: validateIndividualTag,
      generateReport: generateShareableReport,
    },
  };
}
